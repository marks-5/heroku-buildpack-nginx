#!/usr/bin/env bash

psmgr=/tmp/nginx-buildpack-wait
rm -f $psmgr
mkfifo $psmgr

#Evaluate config to get $PORT
erb config/nginx.conf.erb > config/nginx.conf

#Start log redirection.
(
	#Initialize log directory.
	mkdir -p logs/nginx
	touch logs/nginx/access.log logs/nginx/error.log
	#Redirect NGINX logs to stdout.
	exec tail -qF -n 0 logs/nginx/*.log &
	echo 'buildpack=nginx at=logs-initialized'
	wait
	echo 'logs' >$psmgr
) &

#Start App Server
(
	#Take the command passed to this bin and start it.
	#E.g. bin/start-nginx bundle exec unicorn -c config/unicorn.rb
	exec $@ &
	echo "buildpack=nginx at=start-app cmd=$@"
	wait
	echo 'app' >$psmgr
) &
#We block on app-initialized so that when NGINX binds to $PORT
#are app is ready for traffic.
while [[ ! -f /tmp/app-initialized ]]
do
	echo 'buildpack=nginx at=app-initialization'
	sleep 1
done
echo 'buildpack=nginx at=app-initialized'

#Start NGINX
(
	#We expect nginx to run in foreground.
	#We also expect a socket to be at /tmp/nginx.socket.
	exec bin/nginx -p . -c config/nginx.conf &
	echo 'buildpack=nginx at=nginx-started'
	wait
	echo 'nginx' >$psmgr
) &

#This read will block the process waiting on a msg to be put into the fifo.
#If any of the processes defined above should exit,
#a msg will be put into the fifo causing the read operation
#to un-block. The process putting the msg into the fifo
#will use it's process name as a msg so that we can print the offending
#process to stdout.
read exit_process <$psmgr
echo "buildpack=nginx at=exit process=$exit_process"
exit 1
